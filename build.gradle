// -*- mode:groovy; coding:utf-8; -*-

//  A Gradle build for the JSR 166 artefacts.  This build replaces the Ant build.
//
//  Copyright Â© 2011 Russel Winder

//  Author:  Russel Winder <russel@russel.org.uk>

allprojects {
  group = 'org.codehaus.jsr166'
  versionRoot = ( new File ( 'version.properties' ) ).text.trim ( ) 
  version = versionRoot + '-SNAPSHOT'
  bundleVersion = versionRoot + '.SNAPSHOT'
  projectWebsite = 'http://jsr166.codehaus.org'
}

subprojects {
  apply plugin: 'java'
  apply plugin: 'osgi'
  apply plugin: 'maven'
  sourceCompatibility = 6
  // Without the -XDignore.symbol.file=true option there are compilation errors.
  compileJava.options.compilerArgs = [ '-Xlint' , '-XDignore.symbol.file=true' ]
  repositories { mavenCentral ( ) }
  defaultTasks 'build'
  //
  //  Gradle currently has facility to append to the bootclasspath but not prepend, which is what is needed
  //  since some of the JSR166 classes replace ones in the Java distribution so the JSR 166 classes must
  //  appear earlier in the classpath than the Java distribution ones.  This means we have to provide the
  //  whole of the bootclasspath, which is going to be a nightmare to handle in a truly platform independent
  //  way :-(
  //
  bootClasspathCollection = files ( '../jsr166/build/libs/jsr166-' + version + '.jar' , '/usr/lib/jvm/java-6-openjdk/jre/lib/rt.jar' )
  bootClasspath = bootClasspathCollection.asPath
  //
  def theVendor = 'Doug Lea'
  jar {
    manifest {
      version = bundleVersion
      instruction 'Bundle-Vendor' , theVendor
      instruction 'Bundle-Description' , group
      instruction 'Bundle-DocURL' , projectWebsite
      instruction 'Built-By' , System.properties.'user.name'
      instruction 'Specification-Version' , bundleVersion
      instruction 'Specification-Vendor' , theVendor
      instruction 'Implementation-Version' , bundleVersion
      instruction 'Implementation-Vendor' , theVendor
      instruction 'provider' , theVendor
      instruction 'Export-Package' , "*;version=${version}"
      instruction 'Import-Package', '*;resolution:=optional'
    }
  }
}

//  In order to test the JSR166 material we have to create a jar so that it can be prepended it to the
//  bootclasspath of the JVM executing the tests.  This is necessary as the JSR 166 code believes it is part
//  of the Java core, thus it must be loaded by the bootstrap loader and not the system loader -- loading
//  with the system loader leads to a number of security exceptions.  A project is not allowed to depend on
//  itself so we cannot use the standard Java lifecycle.  Hence break out the TCK as a separate project to
//  allow for the appropirate dependencies.

project ( ':jsr166' ) {
  sourceSets { main { java { srcDir '../src/main' } } }
  jar {
    manifest { 
      name = 'jsr166'
      symbolicName = 'jsr166'
      instruction 'Extension-Name' , 'jsr166'
      instruction 'Specification-Title' , 'JSR166'
      instruction 'Implementation-Title' , 'JSR166'
    }
  }
}

//  Compiling these other materials is a bit tricky as we should be using the jsr166.jar above rather than
//  the versions of the classes in the Java core.  Remeber we have to include it in teh bootclasspath not
//  the classpath.  However, it seems the we have to depend on the jar in the classpath so that it is
//  guaranteed to be available as a jar for use in the bootclasspath.

//  To save hassle we simply handle the TCK source as main code to get the jar for :extra166y:test needs and
//  as tests to run the TCL again JSR166.  Sever duplication but it seems the only way of trivially using
//  Gradle.

project ( ':jsr166tck' ) {
  sourceSets {
    main { java { srcDir '../src/test/tck' } }
    test { java { srcDir '../src/test/tck' } }
  }
  dependencies { compile project ( ':jsr166' ) , 'junit:junit:4.8.2' }
  compileJava.options.bootClasspath = bootClasspath
  test.bootstrapClasspath = bootClasspathCollection
  jar {
    manifest { 
      name = 'jsr166tck'
      symbolicName = 'jsr166tck'
      instruction 'Extension-Name' , 'jsr166x'
      instruction 'Specification-Title' , 'JSR166 TCK'
      instruction 'Implementation-Title' , 'JSR166 TCK'
    }
  }
}

project ( ':jsr166x' ) {
  sourceSets { main { java { srcDir '../src/jsr166x' } } }
  dependencies { compile project ( ':jsr166' ) }
  compileJava.options.bootClasspath = bootClasspath
  def theTitle = 'JSR166x'
  jar {
    manifest { 
      name = 'jsr166x'
      symbolicName = 'jsr166x'
      instruction 'Extension-Name' , 'jsr166x'
      instruction 'Specification-Title' , 'JSR166x'
      instruction 'Implementation-Title' , 'JSR166x'
    }
  }
}

project ( ':jsr166y' ) {
  sourceSets { main { java { srcDir '../src/jsr166y' } } }
  dependencies { compile project ( ':jsr166' ) }
  compileJava.options.bootClasspath = bootClasspath
  def theTitle = 'JSR166y'
  jar {
    manifest { 
      name = 'jsr166y'
      symbolicName = 'jsr166y'
      instruction 'Extension-Name' , 'jsr166y'
      instruction 'Specification-Title' , 'JSR166y'
      instruction 'Implementation-Title' , 'JSR166y'
    }
  }
}

project ( ':extra166y' ) {
  sourceSets {
    main { java { srcDir '../src/extra166y' } }
    test { java { srcDir '../src/test/extra166y' } }
  }
  compileJava.options.bootClasspath = bootClasspath
  test.bootstrapClasspath = bootClasspathCollection
  dependencies {
    compile project ( ':jsr166' ) , project ( ':jsr166y' )
    testCompile project ( ':jsr166tck' )  // The extra166y tests depend on classes in the TCK.
  }
  def theTitle = 'Extra166y'
  jar {
    manifest { 
      name = 'extra166y'
      symbolicName = 'extra166y'
      instruction 'Extension-Name' , 'extra166y'
      instruction 'Specification-Title' , 'Extra166y'
      instruction 'Implementation-Title' , 'Extra166y'
    }
  }
}

task clobber ( description : 'Clean all the Gradle subproject directories since they are transient.  All the permanent material is not in the subproject directories.' ) << {
  childProjects.keySet ( ).each { item -> delete ( item ) }
}
