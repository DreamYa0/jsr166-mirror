// -*- mode:groovy; coding:utf-8; -*-

//  A Gradle build for the JSR 166 artefacts.  This build replaces the Ant build.
//
//  Copyright © 2011–2012 Russel Winder

//  Author:  Russel Winder <russel@russel.org.uk>

final isSnapshot = true

allprojects {
  group = 'org.codehaus.jsr166-mirror'
  final versionRoot = ( new File ( 'version.properties' ) ).text.trim ( )
  version = versionRoot + ( isSnapshot ? '-SNAPSHOT' : '' )
  ext.bundleVersion = versionRoot + ( isSnapshot ? '.SNAPSHOT' : '' )
  ext.projectWebsite = 'http://jsr166.codehaus.org'
}

subprojects {
  apply plugin: 'java'
  apply plugin: 'osgi'
  apply plugin: 'maven'
  repositories { mavenCentral ( ) }
  defaultTasks 'build'
  //
  //  Gradle currently has facility to append to the bootclasspath but not prepend, which is what is needed
  //  since some of the JSR166 classes replace ones in the Java distribution, so the JSR 166 classes must
  //  appear earlier in the classpath than the Java distribution ones.  This means we have to provide the
  //  whole of the bootclasspath, which is going to be a nightmare to handle in a platform independent way
  //  :-(
  //
  //ext.bootClasspathCollection = files ( '../jsr166/build/libs/jsr166-' + version + '.jar' , '/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar' )
  //ext.bootClasspath = bootClasspathCollection.asPath
  //
  configurations {
    deployJars
  }
  dependencies {
    deployJars 'org.apache.maven.wagon:wagon-http-lightweight:2.0'
  }
  def theVendor = 'Doug Lea'
  jar {
    manifest {
      version = bundleVersion
      instruction 'Bundle-Vendor' , theVendor
      instruction 'Bundle-Description' , group
      instruction 'Bundle-DocURL' , projectWebsite
      instruction 'Built-By' , System.properties.'user.name'
      instruction 'Specification-Version' , bundleVersion
      instruction 'Specification-Vendor' , theVendor
      instruction 'Implementation-Version' , bundleVersion
      instruction 'Implementation-Vendor' , theVendor
      instruction 'provider' , theVendor
      instruction 'Export-Package' , "*;version=${version}"
      instruction 'Import-Package', '*;resolution:=optional'
    }
    task javadocArtifact ( type  : Jar , dependsOn : 'javadoc' ) {
      classifier = 'javadoc'
      from docsDir
    }
    task sourceArtifact ( type : Jar ) {
      classifier = 'sources'
      //  Specification of the file set is in the per module specification to allow for variant structuring.
    }
    artifacts {
      archives ( javadocArtifact )
      archives ( sourceArtifact )
    }
  }

  try {
    uploadArchives {
      repositories.mavenDeployer {
        uniqueVersion = false
        configuration = configurations.deployJars

        repository ( url : 'https://dav.codehaus.org/repository/jsr166-mirror/' ) {
          authentication ( userName : codehausUsername , password : codehausPassword )
        }
        snapshotRepository ( url : 'https://dav.codehaus.org/snapshots.repository/jsr166-mirror/' ) {
          authentication ( userName: codehausUsername , password : codehausPassword )
        }
        /*
        repository ( url : 'https://nexus.codehaus.org/service/local/staging/deploy/maven2/' ) {
          authentication ( userName : codehausUsername , password : codehausPassword )
        }
        snapshotRepository ( url : 'https://nexus.codehaus.org/content/repositories/snapshots/' ) {
          authentication ( userName : codehausUsername , password : codehausPassword )
        }
        */
      }
    }
  }
  catch ( Exception e ) {
    //  If codehausUsername and/or codehausPassword are not defined, do nothing.
  }
}

//  In order to test the JSR166 material we have to create a jar so that it can be prepended to the
//  bootclasspath of the JVM executing the tests.  This is necessary as the JSR 166 code believes it is part
//  of the Java core, thus it must be loaded by the bootstrap loader and not the system loader -- loading
//  with the system loader leads to a number of security exceptions.  A project is not allowed to depend on
//  itself so we cannot use the standard Java lifecycle.  Hence break out the TCK as a separate project to
//  allow for the appropriate dependencies.

project ( ':jsr166' ) {
  sourceCompatibility = 6
  targetCompatibility = 6
  sourceSets { main { java { srcDir '../src/main' } } }
  // Without the -XDignore.symbol.file=true option there are compilation errors. When Gradle switched from
  // using the Ant task for handling compilation to handling it internally this broke. So we have to enforce
  // using the Ant task so as to get the parameter into place.
  //
  // cf. http://forums.gradle.org/gradle/topics/how_to_set_xdignore_symbol_file_true_on_some_compiles_in_multi_project_build
  compileJava.options.useAnt = true
  compileJava.options.compilerArgs = [ '-XDignore.symbol.file=true' ]
  jar {
    manifest {
      name = 'jsr166'
      symbolicName = 'jsr166'
      instruction 'Extension-Name' , 'jsr166'
      instruction 'Specification-Title' , 'JSR166'
      instruction 'Implementation-Title' , 'JSR166'
    }
  }
  sourceArtifact { from sourceSets.main.allSource }
}

//  Compiling these other materials is a bit tricky as we should be using the jsr166.jar above rather than
//  the versions of the classes in the Java core.  Remember we have to include it in the bootclasspath not
//  the classpath.  However, it seems the we have to depend on the jar in the classpath so that it is
//  guaranteed to be available as a jar for use in the bootclasspath.

//  To save hassle in defining the TCK project, we simply duplicate the compilation in both compileJava and
//  test tasks.  This saves having to replicate all the test processing which Gradle knows how to do at the
//  expense of double the compilation and double the disk space.  It also means that :extra166y:test can
//  just depend on the jsr166tck.jar for the dependencies it needs.

project ( ':jsr166tck' ) {
  sourceCompatibility = 6
  targetCompatibility = 6
  sourceSets {
    main { java { srcDir '../src/test/tck' } }
    test { java { srcDir '../src/test/tck' } }
  }
  dependencies { compile 'junit:junit:3.8.2' }
  compileJava.dependsOn project ( ':jsr166' ).jar
  //compileJava.options.bootClasspath = bootClasspath
  //compileTestJava.options.bootClasspath = bootClasspath
  //test.bootstrapClasspath = bootClasspathCollection
  jar {
    manifest {
      name = 'jsr166tck'
      symbolicName = 'jsr166tck'
      instruction 'Extension-Name' , 'jsr166tck'
      instruction 'Specification-Title' , 'JSR166 TCK'
      instruction 'Implementation-Title' , 'JSR166 TCK'
    }
  }
  sourceArtifact { from sourceSets.main.allSource }
}

project ( ':jsr166x' ) {
  sourceCompatibility = 6
  targetCompatibility = 6
  sourceSets { main { java { srcDir '../src/jsr166x' } } }
  // Assume using Java 7 replaces this need.
  //compileJava.dependsOn project ( ':jsr166' ).jar
  //compileJava.options.bootClasspath = bootClasspath
  jar {
    manifest {
      name = 'jsr166x'
      symbolicName = 'jsr166x'
      instruction 'Extension-Name' , 'jsr166x'
      instruction 'Specification-Title' , 'JSR166x'
      instruction 'Implementation-Title' , 'JSR166x'
    }
  }
  sourceArtifact { into ( 'jsr166x' ) { from sourceSets.main.allSource } }
}

project ( ':jsr166y' ) {
  sourceCompatibility = 6
  targetCompatibility = 6
  sourceSets { main { java { srcDir '../src/jsr166y' } } }
  // Assume using Java 7 replaces this need.
  //compileJava.dependsOn project ( ':jsr166' ).jar
  //compileJava.options.bootClasspath = bootClasspath
  jar {
    manifest {
      name = 'jsr166y'
      symbolicName = 'jsr166y'
      instruction 'Extension-Name' , 'jsr166y'
      instruction 'Specification-Title' , 'JSR166y'
      instruction 'Implementation-Title' , 'JSR166y'
    }
  }
  sourceArtifact { into ( 'jsr166y' ) { from sourceSets.main.allSource } }
}

project ( ':extra166y' ) {
  sourceCompatibility = 6
  targetCompatibility = 6
  sourceSets {
    main { java { srcDir '../src/extra166y' } }
    test { java { srcDir '../src/test/extra166y' } }
  }
  // Assume using Java 7 replaces this need.
  //compileJava.dependsOn project ( ':jsr166' ).jar
  //compileJava.options.bootClasspath = bootClasspath
  //compileTestJava.options.bootClasspath = bootClasspath
  //test.bootstrapClasspath = bootClasspathCollection
  //  It seems that the jars are never not rebuilt -- something in the manifest means that the jars are
  //  rebuilt on every run.  Do not therefore depend on the jars, but instead on the compiled classes.
  dependencies {
    //  At some point in between 1.0-milestone-3 and the 1.0-milestone-4 snapshots, the classes property was
    //  deprecated.  Leave the new versions commented out pending upgrade from 1.0-milestone-3 which doesn't
    //  have the change.
    compile files ( project ( ':jsr166y' ).sourceSets.main.output )
    testCompile 'junit:junit:3.8.2' // , files ( project ( ':jsr166tck' ).sourceSets.main.output )  // The extra166y tests depend on classes in the TCK.
  }
  jar {
    manifest {
      name = 'extra166y'
      symbolicName = 'extra166y'
      instruction 'Extension-Name' , 'extra166y'
      instruction 'Specification-Title' , 'Extra166y'
      instruction 'Implementation-Title' , 'Extra166y'
    }
  }
  sourceArtifact { into ( 'extra166y' ) { from sourceSets.main.allSource } }
}

project ( ':jsr166e' ) {
  sourceCompatibility = 7
  targetCompatibility = 7
  sourceSets { main { java { srcDir '../src/jsr166e' } } }
  jar {
    manifest {
      name = 'jsr166e'
      symbolicName = 'jsr166e'
      instruction 'Extension-Name' , 'jsr166e'
      instruction 'Specification-Title' , 'JSR166e'
      instruction 'Implementation-Title' , 'JSR166e'
    }
  }
  sourceArtifact { into ( 'jsr166e' ) { from sourceSets.main.allSource } }
}

task clobber ( description : 'Clean all the Gradle subproject directories since they are transient.  All the permanent material is not in the subproject directories.' ) << {
  childProjects.keySet ( ).each { item -> delete ( item ) }
}

task wrapper ( type : Wrapper ) {
    gradleVersion = '1.2'
}
